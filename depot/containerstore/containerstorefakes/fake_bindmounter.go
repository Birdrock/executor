// This file was generated by counterfeiter
package containerstorefakes

import (
	"sync"

	"github.com/cloudfoundry-incubator/executor"
	"github.com/cloudfoundry-incubator/executor/depot/containerstore"
	"github.com/cloudfoundry-incubator/executor/depot/log_streamer"
	"github.com/pivotal-golang/lager"
)

type FakeBindMounter struct {
	DownloadBindMountsStub        func(logger lager.Logger, mounts []executor.BindMount, logStreamer log_streamer.LogStreamer) (containerstore.BindMounts, error)
	downloadBindMountsMutex       sync.RWMutex
	downloadBindMountsArgsForCall []struct {
		logger      lager.Logger
		mounts      []executor.BindMount
		logStreamer log_streamer.LogStreamer
	}
	downloadBindMountsReturns struct {
		result1 containerstore.BindMounts
		result2 error
	}
	ExpireCacheKeysStub        func(logger lager.Logger, keys []containerstore.BindMountCacheKey) error
	expireCacheKeysMutex       sync.RWMutex
	expireCacheKeysArgsForCall []struct {
		logger lager.Logger
		keys   []containerstore.BindMountCacheKey
	}
	expireCacheKeysReturns struct {
		result1 error
	}
}

func (fake *FakeBindMounter) DownloadBindMounts(logger lager.Logger, mounts []executor.BindMount, logStreamer log_streamer.LogStreamer) (containerstore.BindMounts, error) {
	fake.downloadBindMountsMutex.Lock()
	fake.downloadBindMountsArgsForCall = append(fake.downloadBindMountsArgsForCall, struct {
		logger      lager.Logger
		mounts      []executor.BindMount
		logStreamer log_streamer.LogStreamer
	}{logger, mounts, logStreamer})
	fake.downloadBindMountsMutex.Unlock()
	if fake.DownloadBindMountsStub != nil {
		return fake.DownloadBindMountsStub(logger, mounts, logStreamer)
	} else {
		return fake.downloadBindMountsReturns.result1, fake.downloadBindMountsReturns.result2
	}
}

func (fake *FakeBindMounter) DownloadBindMountsCallCount() int {
	fake.downloadBindMountsMutex.RLock()
	defer fake.downloadBindMountsMutex.RUnlock()
	return len(fake.downloadBindMountsArgsForCall)
}

func (fake *FakeBindMounter) DownloadBindMountsArgsForCall(i int) (lager.Logger, []executor.BindMount, log_streamer.LogStreamer) {
	fake.downloadBindMountsMutex.RLock()
	defer fake.downloadBindMountsMutex.RUnlock()
	return fake.downloadBindMountsArgsForCall[i].logger, fake.downloadBindMountsArgsForCall[i].mounts, fake.downloadBindMountsArgsForCall[i].logStreamer
}

func (fake *FakeBindMounter) DownloadBindMountsReturns(result1 containerstore.BindMounts, result2 error) {
	fake.DownloadBindMountsStub = nil
	fake.downloadBindMountsReturns = struct {
		result1 containerstore.BindMounts
		result2 error
	}{result1, result2}
}

func (fake *FakeBindMounter) ExpireCacheKeys(logger lager.Logger, keys []containerstore.BindMountCacheKey) error {
	fake.expireCacheKeysMutex.Lock()
	fake.expireCacheKeysArgsForCall = append(fake.expireCacheKeysArgsForCall, struct {
		logger lager.Logger
		keys   []containerstore.BindMountCacheKey
	}{logger, keys})
	fake.expireCacheKeysMutex.Unlock()
	if fake.ExpireCacheKeysStub != nil {
		return fake.ExpireCacheKeysStub(logger, keys)
	} else {
		return fake.expireCacheKeysReturns.result1
	}
}

func (fake *FakeBindMounter) ExpireCacheKeysCallCount() int {
	fake.expireCacheKeysMutex.RLock()
	defer fake.expireCacheKeysMutex.RUnlock()
	return len(fake.expireCacheKeysArgsForCall)
}

func (fake *FakeBindMounter) ExpireCacheKeysArgsForCall(i int) (lager.Logger, []containerstore.BindMountCacheKey) {
	fake.expireCacheKeysMutex.RLock()
	defer fake.expireCacheKeysMutex.RUnlock()
	return fake.expireCacheKeysArgsForCall[i].logger, fake.expireCacheKeysArgsForCall[i].keys
}

func (fake *FakeBindMounter) ExpireCacheKeysReturns(result1 error) {
	fake.ExpireCacheKeysStub = nil
	fake.expireCacheKeysReturns = struct {
		result1 error
	}{result1}
}

var _ containerstore.BindMounter = new(FakeBindMounter)
